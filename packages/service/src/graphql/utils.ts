import type { mrapi } from '../types'

import { dirname, join } from 'path'
import { writeFileSync, mkdirSync } from 'fs'
import { tryRequire, defaults } from '@mrapi/common'

const FILE_HEADER = `/**
* This file was generated by mrapi
* Do not make changes to this file directly
*/
`

export function createSchema(
  service: mrapi.ServiceOptions,
  isMultiService: boolean = false,
  { makeSchema }: typeof import('@nexus/schema'),
) {
  const customPath = (service.graphql as mrapi.GraphqlOptions).custom!
  const generateTo = join(customPath, 'generated')
  const contextDir = join(
    dirname((service.graphql as mrapi.GraphqlOptions).output!),
    'context',
  )
  const customTypes = tryRequire(customPath)
  let types = Array.isArray(customTypes) ? customTypes : [customTypes]
  let plugins: any[] = []
  const usingPrisma = !!service.prisma

  let prismaClientModuleName: string
  if (usingPrisma) {
    const sources = getPrismaRsources(service, isMultiService, generateTo)
    types = types.concat(sources.types)
    plugins = plugins.concat(sources.plugins)
    prismaClientModuleName = (service.prisma as mrapi.PrismaOptions)?.output!.split(
      'node_modules/',
    )[1]
  }

  // TODO: support custom prettier config
  let prettierConfig = {
    semi: false,
    tabWidth: 2,
    singleQuote: true,
    trailingComma: 'all',
  }

  // create `Context` file
  mkdirSync(contextDir, { recursive: true })
  writeFileSync(
    join(contextDir, 'index.d.ts'),
    !!prismaClientModuleName!
      ? `${FILE_HEADER}

import { PrismaClient } from '${prismaClientModuleName!}'

export interface Context {
  prisma: PrismaClient
}`
      : `export interface Context {
}
`,
  )

  const schema = makeSchema({
    types,
    plugins,
    prettierConfig,
    nonNullDefaults: {
      // Whether output fields are non-null by default. default: false
      output: true,
      // Whether input fields (field arguments, input type members) are non-null by default. default: false
      // input: true,
    },
    shouldGenerateArtifacts: false,
    // outputs: {
    //   typegen: join(generateTo, 'nexus.d.ts'),
    //   schema: join(generateTo, 'api.graphql'),
    // },
    outputs: false,
    ...(usingPrisma
      ? {
          typegenAutoConfig: {
            headers: [FILE_HEADER],
            backingTypeMap: {
              DateTime: 'Date',
              Email: 'string',
              JSONObject: 'prisma.JsonObject',
            },
            contextType: 'ctx.Context',
            sources: [
              {
                alias: 'ctx',
                source: contextDir,
              },
              {
                alias: 'prisma',
                source: join(prismaClientModuleName!, 'index.d.ts'),
              },
              {
                alias: 'models',
                source: join(customPath, 'models/index.ts'),
                // Note: This will match any declared type in models if the name matches
                typeMatch: (type) => [new RegExp(`(${type.name})`)],
              },
            ],
            debug: true,
          },
        }
      : {}),
  })

  if (service.mock) {
    const {
      addMocksToSchema,
    }: typeof import('@graphql-tools/mock') = tryRequire(
      '@graphql-tools/mock',
      'You are using graphql mock, please install it manually.',
    )
    const mocks = typeof service.mock === 'object' ? service.mock : {}
    return addMocksToSchema({ schema, mocks })
  }

  return schema
}

function getPrismaRsources(
  service: mrapi.ServiceOptions,
  isMultiService: boolean,
  _generateTo: string,
) {
  const { nexusPrisma }: typeof import('nexus-plugin-prisma') = tryRequire(
    'nexus-plugin-prisma',
    'Please install it manually.',
  )
  const { dbClientPath, textRunGraphql } = checkDBClient(
    service,
    isMultiService,
  )

  // generated types
  let types = []
  const graphqlOptions = service.graphql as mrapi.GraphqlOptions
  if (graphqlOptions?.output) {
    const generatedTypes = tryRequire(graphqlOptions?.output)
    if (!generatedTypes) {
      throw new Error(
        `You most likely forgot to generate the GraphQL APIs.
Please run ${textRunGraphql} and try to run it again.${
          isMultiService
            ? `
You also can run \`npx mrapi graphql --service=.\` to generate all services's GraphQL API.`
            : ''
        }`,
      )
    }

    types.push(generatedTypes)
  }

  return {
    types,
    plugins: [
      nexusPrisma({
        // https://nexusjs.org/docs/pluginss/prisma/overview#configuration
        /**
         * nexus-prisma will call this to get a reference to an instance of the Prisma Client.
         * The function is passed the context object. Typically a Prisma Client instance will
         * be available on the context to support your custom resolvers. Therefore the
         * default getter returns `ctx.prisma`.
         */
        // prismaClient?: PrismaClientFetcher
        // keep default, because paljs using `prisma`: https://github.com/paljs/prisma-tools/blob/master/packages/generator/src/nexus/templates/findOne.ts
        // prismaClient: (ctx) => ctx.db,
        /**
         * Same purpose as for that used in `Nexus.makeSchema`. Follows the same rules
         * and permits the same environment variables. This configuration will completely
         * go away once Nexus has typeGen plugin support.
         */
        shouldGenerateArtifacts: false,
        /**
         * Enable experimental CRUD capabilities.
         * Add a `t.crud` method in your definition block to generate CRUD resolvers in your `Query` and `Mutation` GraphQL Object Type.
         *
         * @default false
         */
        experimentalCRUD: true,
        inputs: {
          /**
           * What is the path to the Prisma Client package? By default looks in
           * `node_modules/@prisma/client`. This is needed in order to read your Prisma
           * schema AST and Prisma Client CRUD info from the generated Prisma Client package.
           */
          prismaClient: dbClientPath,
        },
        // outputs: {
        /**
         * Where should nexus-prisma put its typegen on disk?
         *
         * @default 'node_modules/@types/typegen-nexus-plugin-prisma/index.d.ts'
         *
         * @remarks
         *
         * This configuration will completely go away once Nexus has typeGen plugin
         * support.
         *
         */
        //   typegen: join(_, 'nexus-prisma.d.ts'),
        // },
      }),
    ],
  }
}

export const defaultQuery = `{
  hello
}
`

export function createGraphqlExtensions(tenantId?: string) {
  // return ({ document, variables, operationName, result, context }: any) => {
  return ({ result, context }: any) => {
    if (Array.isArray(result.errors)) {
      result.errors.map((error: Error) => console.error(error.stack))
    }
    return {
      ...(tenantId ? { tenantId } : {}),
      ...(context.startTime ? { duation: Date.now() - context.startTime } : {}),
    }
  }
}

export function checkDBClient(
  service: mrapi.ServiceOptions,
  isMultiService = false,
) {
  const dbClientPath = service.prisma?.output || defaults.clientPath
  const dbClient = dbClientPath ? tryRequire(dbClientPath, '', false) : null
  const serviceName =
    service.name ||
    (service.management ? 'management' : isMultiService ? service.name : '')

  const textRunGraphql = service.graphql
    ? `\`npx mrapi graphql${serviceName ? ` --service=${serviceName}` : ''}\``
    : ''

  if (!dbClient || !dbClient.prismaVersion) {
    throw new Error(
      `You most likely forgot to initialize the Prisma Client. Please run \`npx mrapi setup\`, then try to run it again.`,
    )
  }

  return {
    textRunGraphql,
    dbClientPath,
  }
}
